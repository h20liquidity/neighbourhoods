/* Calculate IO */

/* refuse any counterparties other than named */
allowed-counterparty: {{ counterparty }},
: ensure(eq(allowed-counterparty context<1 2>())),

/* 24 hour delay on new batches = 86400 seconds */
batch-start-info-k: context<1 0>(),
batch-start-info: get(batch-start-info-k),
batch-start-time: decode-256<32 63>(batch-start-info),
: ensure(gt(now() add(batch-start-time 86400))),

/* get info about current batch */
batch-index batch-remaining: call<2 2>(0),

/* exponential growth */
/* (1.02)^batch-index */
/* Power function x^y with y simple integer */
/* https://github.com/PaulRBerg/prb-math */
io-multiplier: prb-powu(102e16 batch-index),
/* always offer at least 10 tokens even if that's beyond the current batch */
amount: max(batch-remaining 0),

io-ratio: prb-mul(io-multiplier {{ ratio }});

/*
 * Handle IO
 * Actual order size available here after cross referencing counterparty order
 */
batch-start-info-k: context<1 0>(),
total-sent-k: hash(context<1 0>()),

/* new batch info due to trade */
out-token-amount: context<4 4>(),
out-token-decimals: context<4 1>(),
new-total-sent new-batch-index _: call<2 3>(scale-18-dynamic<0 1>(out-token-decimals out-token-amount)),

/* stored batch info */
batch-start-info: get(batch-start-info-k),
batch-start-index: decode-256<0 31>(batch-start-info),
batch-start-time: decode-256<32 63>(batch-start-info),

/* if we're in a new batch record current time as batch start time */
:set(
  batch-start-info-k
  if(
    gt(new-batch-index batch-start-index)
    encode-256<32 63>(now() encode-256<0 31>(new-batch-index 0))
    batch-start-info)),
:set(total-sent-k new-total-sent);

/* Calculate batch */
new-sent:,
total-sent-k: hash(context<1 0>()),
amount-per-batch: 1000e18,
new-total-amount-sent: add(get(total-sent-k) new-sent),
/* use the flooring from integer division to simply batch the order */
new-batch-index: div(new-total-amount-sent amount-per-batch),
new-batch-remaining: sub(
  mul(
    add(new-batch-index 1)
    amount-per-batch)
  new-total-amount-sent);
